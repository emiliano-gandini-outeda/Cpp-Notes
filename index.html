<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C++ Notes</title>
    <link rel="icon" type="image/png" href="https://upload.wikimedia.org/wikipedia/commons/thumb/1/18/ISO_C%2B%2B_Logo.svg/250px-ISO_C%2B%2B_Logo.svg.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <style>
        :root {
            --color-dark-grey: #2D2D2D;
            --color-background: #111217;
            --color-surface: #3A3A3A;
            --color-dark-red: #B71C1C;
            --color-dark-red-light: #D32F2F;
            --color-text-primary: #E0E0E0;
            --color-text-secondary: #B0B0B0;
            --color-borders: #4A4A4A;
        }
        body {
            background-color: var(--color-background);
            color: var(--color-text-primary);
            font-family: 'Inter', sans-serif;
        }
    </style>
</head>

<body>
    
<!-- Hero Section -->
<section class="relative h-[60vh] flex flex-col items-center justify-center text-center bg-cover bg-center" style="background-image: url(c++.jpg)">
    <div class="bg-[rgba(26,26,26,0.7)] absolute inset-0"></div>
    <div class="relative z-10">
        <h1 class="text-4xl md:text-6xl font-extrabold mb-4">C++ Notes</h1>
        <p class="text-lg text-[var(--color-text-secondary)] max-w-xl mx-auto">
        C++ notes from my studies, made onto a static site. 
        </p>
    </div>
</section>

<!-- Main -->
<section class="container mx-auto py-8 px-4 flex gap-8" x-data="cardApp()">

    <!-- Sidebar Filters -->
    <aside class="bg-[var(--color-dark-grey)] p-4 rounded-lg w-64 flex-shrink-0"
           style="height: fit-content;">

        <h2 class="text-lg font-bold mb-4">Filters</h2>

        <!-- Filter checkboxes -->
        <div class="flex flex-col gap-2">
            <template x-for="tag in allTags" :key="tag">
                <label class="flex items-center gap-3 cursor-pointer">
                    <input type="checkbox"
                           class="form-checkbox w-5 h-5 text-[var(--color-dark-red)] rounded"
                           :value="tag"
                           @change="toggleTag(tag)"
                           :checked="selectedTags.includes(tag)">
                    <span x-text="tag" class="text-[var(--color-text-primary)]"></span>
                </label>
            </template>
        </div>

        <!-- Clear filters button -->
        <button @click="selectedTags = []"
                class="mt-4 w-full py-2 rounded bg-[var(--color-dark-red)]
                       text-[var(--color-text-primary)]
                       hover:bg-[var(--color-dark-red-light)] transition">
            Clear Filters
        </button>
    </aside>

    <!-- Main Content -->
    <div class="flex-1">
        <!-- Search Bar -->
        <div class="relative w-full mb-6">
            <span class="absolute inset-y-0 left-4 flex items-center pointer-events-none text-[var(--color-text-secondary)]">
                <!-- Search Icon -->
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none"
                     viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round"
                          d="M21 21l-4.35-4.35m0 0A7.5 7.5 0 1110.65 5.65a7.5 7.5 0 016.0 11.0z" />
                </svg>
            </span>
            <input type="text" placeholder="Search cards..."
                class="w-full pl-12 pr-4 py-2 rounded-full border border-[var(--color-borders)]
                        bg-[var(--color-surface)] text-[var(--color-text-primary)]
                        placeholder-[var(--color-text-secondary)]
                        focus:outline-none
                        focus:border-[var(--color-dark-red)]
                        focus:ring-2 focus:ring-[var(--color-dark-red)]
                        shadow-sm transition"
                x-model="searchQuery">
        </div>
        
        <!-- Cards -->
        <div class="mt-8">
            <h2 class="font-extrabold uppercase text-xl tracking-wide mb-6">Topics</h2>

            <!-- Masonry container -->
            <div id="masonry-container" class="relative">
                <template x-for="card in filteredCards" :key="card.title">
                    <div class="masonry-item bg-[var(--color-surface)] text-[var(--color-text-primary)]
                                rounded shadow p-4 hover:shadow-lg transition flex flex-col overflow-hidden
                                absolute opacity-0"
                         x-init="$nextTick(() => layoutMasonry())">
                        <!-- Card Title -->
                        <h3 class="text-xl font-bold mb-2 break-words" x-text="card.title"></h3>

                        <!-- Card Text -->
                        <p class="text-[var(--color-text-secondary)] mb-4 break-words" x-text="card.text"></p>

                        <!-- More Button (1/3 width, right-aligned) -->
                        <div class="flex justify-end">
                            <a :href="card.url"
                            class="bg-[var(--color-dark-red)] text-[var(--color-text-primary)] px-4 py-2 rounded
                                    transition duration-300 ease-in-out transform hover:scale-105 active:scale-95
                                    text-center block"
                            style="width: 33.333%;">
                                More
                            </a>
                        </div>
                    </div>
                </template>
            </div>
        </div>
    </div>
</section>


<script>
function cardApp() {
    return {
        // Search input
        searchQuery: '',

        // Selected tags for filtering
        selectedTags: [],

        // All available filters/tags
        allTags: ['Algorithms', 'Search', 'Sorting', 'Syntax', "Data Structures", "Functions", "Data Type", "Operators", "Junior", "Intermediate", "Senior", "Conditionals",],

        // Card data
        cards: [
            { title: 'Basic Syntax Rules', text: 'An overview of the essential rules and structure for writing C++ code.', tags: ['Syntax', "Junior"], url: 'syntax/basic-syntax.html' },
            { title: 'Functions', text: 'A function is a reusable block of code that performs a specific task. It can return a value (non-void) or not return anything (void). Functions help structure programs, reduce code duplication, and improve readability.', tags: ['Functions', "Junior"], url: 'functions/functions.html' },
            { title: 'Basic Data Structures', text: 'Basic data structures are fundamental ways of organizing and storing data, such as arrays, linked lists, stacks, and queues.', tags: ["Data Structures", "Junior", "Data Type"], url: 'data/data-structures.html' },
            { title: 'Algorithms', text: 'An algorithm is a step-by-step procedure for solving a problem or performing a task.', tags: ["Algorithms", "Junior"], url: 'algorithms/algorithms.html' },
            { title: 'Lists', text: 'A list is a dynamic structure that can grow or shrink at runtime.', tags: ["Data Structures", "Junior", "Data Type"], url: 'data/lists.html' },
            { title: 'Arrays', text: 'An array is a fixed-size collection of elements of the same type, stored in contiguous memory.', tags: ["Data Structures", "Junior", "Data Type"], url: 'data/arrays.html' },
            { title: 'scanf', text: 'scanf is a C standard library function defined in <stdio.h> used to read input from the user via the keyboard. ', tags: ['Functions',"Junior"], url: 'functions/scanf.html' },
            { title: 'Character Arrays', text: 'In C++, strings are stored as character arrays ending with a null character "\\0".', tags: ['Data Type', "Junior",], url: 'data/character-array.html' },
            { title: 'Loops', text: 'Loops let you repeat a block of code multiple times, either a fixed number of times or until a condition is met.', tags: ['Functions', "Junior", "Conditionals"], url: 'functions/loops.html' },
            { title: 'Conditional Operators', text: 'Conditional operators compare two values or expressions and return either true (1) or false (0). They’re commonly used in if statements and loops.', tags: ['Operators', "Conditionals", "Junior"], url: 'operators/conditional-operators.html' },
            { title: 'Logical Operators', text: 'Logical operators are used to combine or modify conditions. The result is always either true (1) or false (0).', tags: ['Operators', "Conditionals", "Junior"], url: 'operators/logical-operators.html' },
            { title: 'Conditional Statements', text: 'Conditio  nal statements, such as if, else if, else and switch, allow a program to execute different blocks of code based on whether specific conditions are true or false. ', tags: ["Conditionals", "Junior", "Functions"], url: 'functions/conditional-statements.html' },
            { title: 'printf', text: 'printf is a standard library function used to print formatted output to the console.', tags: ['Functions', "Junior"], url: 'functions/printf.html' },
            { title: 'struct', text: 'A struct is a user-defined data type in C++ that groups related variables, which can be of different types, under one name.', tags: ['Data Type', "Data Structures", "Junior"], url: 'data/struct.html' },
            { title: 'Classes', text: 'A class is a blueprint for creating objects that combines data (attributes) and functions (methods).', tags: ['Data Type', "Data Structures", "Intermediate"], url: 'data/class.html' },
            { title: 'strcpy', text: 'strcpy is a string function from <string.h> that copies one string into another.', tags: ['Function', "Junior"], url: 'functions/strcpy.html' },
            { title: 'Pointers', text: 'A pointer is a variable that stores the memory address of another variable.', tags: ['Data Type', "Data Structures", "Junior"], url: 'data/pointers.html' },
            { title: 'Pointer Arithmetic', text: 'Pointer arithmetic allows moving through memory addresses based on the size of the data type the pointer refers to.', tags: [ "Data Structures", "Intermediate"], url: 'data/pointer-arithmetic.html' },
            { title: 'Arithmetic Operators', text: 'Symbols that tell the compiler to perform specific mathematical operations.', tags: ['Operators', "Junior"], url: 'operators/arithmetic-operators.html' },
            { title: 'Data Types', text: 'A data type defines the kind of data a variable can hold, such as integers, floating-point numbers, characters, or more complex structures.', tags: ['Data Type', "Junior"], url: 'data/data-type.html' },
            { title: 'Format Specifiers', text: 'Format specifiers are placeholders used in functions like printf() and scanf() to tell the program what type of data is being printed or read. They begin with % and are followed by one or more characters that define type, size, and format.', tags: ['Data Type', "Junior"], url: 'data/format-specifiers.html' },
            { title: 'Signed and Unsigned Types', text: 'Integer types like int can store positive and negative numbers by default (signed). You can also declare them as unsigned, which means they can only store non-negative numbers.', tags: ['Data Type', "Intermediate"], url: 'data/signed-unsigned.html' },
            { title: 'Stacks', text: 'A stack is a data structure that stores elements in a last-in, first-out (LIFO) order, where insertion and removal occur only at the top.', tags: ["Data Structures", "Intermediate", "Data Type"], url: 'data/stacks.html' },
            { title: 'Queues', text: 'A queue is a data structure that stores elements in a first-in, first-out (FIFO) order, where insertion occurs at the rear and removal occurs at the front.', tags: ["Data Structures", "Intermediate", "Data Type"], url: 'data/queues.html' },
            { title: 'Linked Lists', text: 'Linked lists are linear data structures made up of nodes, where each node contains a value and one or more pointers (or references) to other nodes.', tags: ["Data Structures", "Junior","Intermediate",], url: 'data/linked-list.html' },
            { title: 'Hash Map', text: 'A hash map is a data structure designed to store key-value pairs and allow very fast access to data using the key.', tags: ["Data Structures", "Intermediate", "Data Type"], url: 'data/hash-map.html' },
            { title: 'Object Oriented Programming', text: 'Object-Oriented Programming (OOP) is a programming paradigm that models entities from the problem domain as objects. Each object combines data (attributes or properties) and behaviors (methods or operations).', tags: ["Data Structures", "Senior",], url: 'data/oop.html' },
            { title: 'Binary Trees', text: 'A binary tree is one in which each node has at most two children, called the left child and the right child.', tags: ["Data Structures", "Intermediate", "Data Type"], url: 'data/binary-tree.html' },
            { title: 'Binary Search Trees', text: 'A binary search tree is a binary tree where each node’s left subtree contains smaller values and the right subtree contains larger values.', tags: ["Data Structures", "Intermediate", "Data Type", "Search"], url: 'data/binary-search-tree.html' },
            { title: 'AVL Tree', text: 'An AVL tree is a balanced binary search tree that ensures the height difference between the left and right subtrees of any node (balance factor) is at most 1.', tags: ["Data Structures", "Senior", "Data Type", "Search"], url: 'data/avl-tree.html' },
            { title: 'Red-Black Tree', text: 'A Red-Black Tree is a balanced binary search tree that ensures a maximum height of 2*log₂(n+1), keeping all operations O(log n) in the worst case.', tags: ["Data Structures", "Senior", "Data Type", "Search"], url: 'data/red-black-tree.html' },
            { title: 'Graphs', text: 'A graph is a data structure consisting of a set of nodes (vertices) and a set of edges that connect pairs of nodes.', tags: ["Data Structures", "Intermediate", "Data Type",], url: 'data/graphs.html' },
            { title: 'Priority Queue', text: 'A priority queue is a data structure that stores elements with an associated priority.', tags: ["Data Structures", "Intermediate", "Data Type",], url: 'data/priority-queue.html' },
            { title: 'Recursion', text: 'A function that calls itself directly or indirectly to solve a problem by breaking it into smaller subproblems.', tags: ["Algorithms", "Intermediate", "Functions",], url: 'functions/recursion.html' },
            { title: 'Heaps', text: 'A heap is a complete binary tree where each node follows the heap property: in a max-heap, nodes are greater than or equal to their children; in a min-heap, nodes are less than or equal to their children.', tags: ["Data Structures", "Senior", "Data Type",], url: 'data/heaps.html' },
            { title: 'Big O Notation', text: 'A mathematical way to describe the upper bound of an algorithm’s running time or space requirement in terms of input size, showing its worst-case growth rate.', tags: ["Algorithms", "Intermediate",], url: 'algorithms/big-o.html' },
            { title: 'Bubble Sort', text: 'A simple sorting algorithm that repeatedly compares and swaps adjacent elements in a list until the entire list is sorted.', tags: ["Algorithms", "Junior", "Sorting"], url: 'algorithms/bubble-sort.html' },
            { title: 'Insertion Sort', text: 'A sorting algorithm that builds the final sorted array one element at a time by repeatedly taking the next element and inserting it into its correct position in the already sorted part.', tags: ["Algorithms", "Junior","Sorting"], url: 'algorithms/insertion-sort.html' },
            { title: 'Selection Sort', text: 'A sorting algorithm that repeatedly selects the smallest (or largest) element from the unsorted portion of a list and swaps it with the first unsorted element.', tags: ["Algorithms", "Junior","Sorting"], url: 'algorithms/selection-sort.html' },
            { title: 'Merge Sort', text: 'A divide-and-conquer sorting algorithm that recursively splits an array into halves, sorts each half, and then merges the sorted halves back together.', tags: ["Algorithms", "Junior","Sorting"], url: 'algorithms/merge-sort.html' },
            { title: 'Quick Sort', text: 'A divide-and-conquer sorting algorithm that selects a pivot element, partitions the array so that elements less than the pivot come before it and greater elements come after, and then recursively sorts the partitions.', tags: ["Algorithms", "Junior","Sorting"], url: 'algorithms/quick-sort.html' },
            { title: 'Lineal Search', text: 'A simple search algorithm that checks each element of a list sequentially until the desired value is found or the list ends.', tags: ["Algorithms", "Junior","Search"], url: 'algorithms/lineal-search.html' },
            { title: 'Binary Search', text: 'A search algorithm that efficiently finds a target value in a sorted array by repeatedly dividing the search interval in half.', tags: ["Algorithms", "Junior","Search"], url: 'algorithms/binary-search.html' },
            { title: 'Depth-First Search', text: 'A graph traversal algorithm that explores as far as possible along each branch before backtracking.', tags: ["Algorithms", "Intermediate","Search"], url: 'algorithms/depth-first-search.html' },
            { title: 'Breadth-First Search', text: 'A graph traversal algorithm that explores all neighbors of a node level by level before moving to the next level.', tags: ["Algorithms", "Intermediate","Search"], url: 'algorithms/breadth-first-search.html' },
            { title: 'Greedy Algorithms', text: 'Problem-solving methods that make the locally optimal choice at each step, hoping to find a global optimum.', tags: ["Algorithms", "Intermediate",], url: 'algorithms/greedy-search1.html' },



        ],

        // Toggle a tag on/off when clicked
        toggleTag(tag) {
            if (this.selectedTags.includes(tag)) {
                this.selectedTags = this.selectedTags.filter(t => t !== tag);
            } else {
                this.selectedTags.push(tag);
            }
        },

        // Filter cards based on search + selected tags
        get filteredCards() {
            const filtered = this.cards.filter(card => {
                const matchesSearch = card.title.toLowerCase().includes(this.searchQuery.toLowerCase()) ||
                                      card.text.toLowerCase().includes(this.searchQuery.toLowerCase());
                const matchesTags = this.selectedTags.length === 0 || card.tags.some(tag => this.selectedTags.includes(tag));
                return matchesSearch && matchesTags;
            });
            
            // Trigger layout after filter changes
            this.$nextTick(() => {
                setTimeout(() => this.layoutMasonry(), 100);
            });
            
            return filtered;
        },

        // Masonry layout function
        layoutMasonry() {
            const container = document.getElementById('masonry-container');
            const items = container.querySelectorAll('.masonry-item');
            
            if (items.length === 0) return;

            // Get container width and calculate columns
            const containerWidth = container.offsetWidth;
            const itemWidth = Math.floor(containerWidth / Math.max(1, Math.floor(containerWidth / 300))); // Min 300px per item
            const columns = Math.floor(containerWidth / itemWidth);
            const gap = 16; // 1rem gap
            
            // Calculate actual item width with gaps
            const actualItemWidth = (containerWidth - (gap * (columns - 1))) / columns;
            
            // Initialize column heights
            const columnHeights = new Array(columns).fill(0);
            
            items.forEach((item, index) => {
                // Set item width
                item.style.width = `${actualItemWidth}px`;
                item.style.position = 'absolute';
                
                // Find shortest column
                let shortestColumn = 0;
                for (let i = 1; i < columnHeights.length; i++) {
                    if (columnHeights[i] < columnHeights[shortestColumn]) {
                        shortestColumn = i;
                    }
                }
                
                // Position item
                const x = shortestColumn * (actualItemWidth + gap);
                const y = columnHeights[shortestColumn];
                
                item.style.left = `${x}px`;
                item.style.top = `${y}px`;
                item.style.opacity = '1';
                
                // Update column height
                columnHeights[shortestColumn] += item.offsetHeight + gap;
            });
            
            // Set container height
            const maxHeight = Math.max(...columnHeights);
            container.style.height = `${maxHeight}px`;
        }
    }
}

// Layout on window resize
window.addEventListener('resize', () => {
    setTimeout(() => {
        const app = Alpine.evaluate(document.querySelector('[x-data="cardApp()"]'), 'layoutMasonry()');
    }, 100);
});
</script>

</body>
</html>